From c1b8eb088c6711598f1b46ad4009a706082594ec Mon Sep 17 00:00:00 2001
From: kwliu <kwliu@nuvoton.com>
Date: Mon, 11 Feb 2019 13:11:12 +0800
Subject: [PATCH] bmcweb: support obmc-ikvm

Signed-off-by: kwliu <kwliu@nuvoton.com>
---
 CMakeLists.txt         |   2 +
 include/obmc_ikvm.hpp  | 141 +++++++++++++++++++++++++++++++++++++++++
 src/webserver_main.cpp |   5 ++
 3 files changed, 148 insertions(+)
 create mode 100755 include/obmc_ikvm.hpp
 mode change 100644 => 100755 src/webserver_main.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2bd8a71..77b4a6b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,8 @@ option (BMCWEB_ENABLE_REDFISH_CPU_LOG "Enable CPU log service transactions
        through Redfish.  Paths are under
        '/redfish/v1/Managers/bmc/LogServices/CpuLog'." OFF)
 
+option (BMCWEB_ENABLE_OBMC_IKVM "Enable OBMC IKVM websocket interfaces" OFF)
+
 # Insecure options.  Every option that starts with a BMCWEB_INSECURE flag should
 # not be enabled by default for any platform, unless the author fully
 # comprehends the implications of doing so.  In general, enabling these options
diff --git a/include/obmc_ikvm.hpp b/include/obmc_ikvm.hpp
new file mode 100755
index 0000000..dcc4cb4
--- /dev/null
+++ b/include/obmc_ikvm.hpp
@@ -0,0 +1,141 @@
+#pragma once
+#include <crow/app.h>
+#include <crow/websocket.h>
+#include <sys/socket.h>
+
+#include <boost/container/flat_map.hpp>
+#include <boost/container/flat_set.hpp>
+#include <webserver_common.hpp>
+
+namespace crow
+{
+namespace obmc_ikvm
+{
+
+static std::unique_ptr<boost::asio::ip::tcp::socket> host_socket;
+
+static std::array<char, 4096> outputBuffer;
+static std::string inputBuffer;
+
+static boost::container::flat_set<crow::websocket::Connection*> sessions;
+
+static bool doingWrite = false;
+
+void doWrite()
+{
+    if (doingWrite)
+    {
+        BMCWEB_LOG_DEBUG << "Already writing.  Bailing out";
+        return;
+    }
+
+    if (inputBuffer.empty())
+    {
+        BMCWEB_LOG_DEBUG << "Outbuffer empty.  Bailing out";
+        return;
+    }
+
+    doingWrite = true;
+    host_socket->async_write_some(
+        boost::asio::buffer(inputBuffer.data(), inputBuffer.size()),
+        [](boost::beast::error_code ec, std::size_t bytes_written) {
+            doingWrite = false;
+            inputBuffer.erase(0, bytes_written);
+
+            if (ec == boost::asio::error::eof)
+            {
+                for (auto session : sessions)
+                {
+                    session->close("Error in reading to host port");
+                }
+                return;
+            }
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "Error in libvncserver write " << ec;
+                return;
+            }
+            doWrite();
+        });
+}
+
+void doRead()
+{
+    BMCWEB_LOG_DEBUG << "Reading from socket";
+    host_socket->async_read_some(
+        boost::asio::buffer(outputBuffer.data(), outputBuffer.size()),
+        [](const boost::system::error_code& ec, std::size_t bytesRead) {
+            BMCWEB_LOG_DEBUG << "read done.  Read " << bytesRead << " bytes";
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "Couldn't read from libvncserver: "
+                                 << ec;
+                for (auto session : sessions)
+                {
+                    session->close("Error in connecting to host port");
+                }
+                return;
+            }
+            boost::beast::string_view payload(outputBuffer.data(), bytesRead);
+            for (auto session : sessions)
+            {
+                session->sendBinary(payload);
+            }
+            doRead();
+        });
+}
+
+void connectHandler(const boost::system::error_code& ec)
+{
+    if (ec)
+    {
+        BMCWEB_LOG_ERROR << "Couldn't connect to libvncserver: " << ec;
+        for (auto session : sessions)
+        {
+            session->close("Error in connecting to host port");
+        }
+        return;
+    }
+
+    doWrite();
+    doRead();
+}
+
+void requestRoutes(CrowApp& app)
+{
+    BMCWEB_ROUTE(app, "/kvmws")
+        .websocket()
+        .onopen([](crow::websocket::Connection& conn) {
+            BMCWEB_LOG_DEBUG << "Connection " << &conn << " opened";
+
+            sessions.insert(&conn);
+            if (host_socket == nullptr)
+            {
+                std::string host = "127.0.0.1";
+                int port = 5900;
+
+                boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(host), 5900);
+                host_socket = std::make_unique<
+                    boost::asio::ip::tcp::socket>(
+                    conn.get_io_context());
+                host_socket->async_connect(endpoint, connectHandler);
+            }
+        })
+        .onclose(
+            [](crow::websocket::Connection& conn, const std::string& reason) {
+                sessions.erase(&conn);
+                if (sessions.empty())
+                {
+                    host_socket = nullptr;
+                    inputBuffer.clear();
+                    inputBuffer.shrink_to_fit();
+                }
+            })
+        .onmessage([](crow::websocket::Connection& conn,
+                      const std::string& data, bool is_binary) {
+            inputBuffer += data;
+            doWrite();
+        });
+}
+} // namespace obmc_console
+} // namespace crow
diff --git a/src/webserver_main.cpp b/src/webserver_main.cpp
old mode 100644
new mode 100755
index 7c64f4c..7125607
--- a/src/webserver_main.cpp
+++ b/src/webserver_main.cpp
@@ -21,6 +21,7 @@
 #include <web_kvm.hpp>
 #include <webassets.hpp>
 #include <webserver_common.hpp>
+#include <obmc_ikvm.hpp>
 
 constexpr int defaultPort = 18080;
 
@@ -80,6 +81,10 @@ int main(int argc, char** argv)
     crow::kvm::requestRoutes(app);
 #endif
 
+#ifdef BMCWEB_ENABLE_OBMC_IKVM
+    crow::obmc_ikvm::requestRoutes(app);
+#endif
+
 #ifdef BMCWEB_ENABLE_REDFISH
     crow::redfish::requestRoutes(app);
 #endif
-- 
2.17.1

